What happens when you initialize a repository? Why do you need to do it?

	When you initialize a repository, git will begin tracking changes and commits made to the repository. This needs to be done because prior to initializing the repository, git will not track changes in the directory. Any file modifications will not be noted and only the most recently saved version of any file will be in the directory. 

How is the staging area different from the working directory and the repository?
What value do you think it offers?

	The staging area has files that are not yet being tracked but will be added to the repository when the next 'git commit' command is run. Files can be added to the staging area from the current working directory using 'git add <file>'. The repository contains only files that are actively being tracked and is a snapshot of all the files at the time of a commit. The staging area contains the files to be added to the repository on the next commit. The current working directory is the folder in which the file(s) one is working on are contained. It can be initialized into a repository in order for changes to start being tracked with the first commmit. I think that it adds the value that files are not automatically committed to the repository each time a commit is made. The developer has to make the decision to add the files from the current working directory to the staging are to be placed in the repository. Sometimes, it might not be the best idea for all of the files in the current working directory to be added into the repository. 
	
How can you use the staging area to make sure you have one commit per logical
change?

	Using the staging area, one can view the differences between the working directory and the staging area (using git diff) and between the staging area and the most recent commit (using git diff --staged). This makes it possible to observe the changes and make sure that only one logical change has been made. Otherwise, the files can be removed from the staging area and only the appropriate files committed to the repository. The staging area is an interesting idea that I am still trying to completely understand, but it seems to be useful in order to prevent unintended changes from being added to the repository every time a commit is completed (using git commit -m 'commit message').
	
What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

How do the diagrams help you visualize the branch structure?

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?
