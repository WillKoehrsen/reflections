What happens when you initialize a repository? Why do you need to do it?

	When you initialize a repository, git will begin tracking changes and commits made to the repository. This needs to be done because prior to initializing the repository, git will not track changes in the directory. Any file modifications will not be noted and only the most recently saved version of any file will be in the directory. 

How is the staging area different from the working directory and the repository?
What value do you think it offers?

	The staging area has files that are not yet being tracked but will be added to the repository when the next 'git commit' command is run. Files can be added to the staging area from the current working directory using 'git add <file>'. The repository contains only files that are actively being tracked and is a snapshot of all the files at the time of a commit. The staging area contains the files to be added to the repository on the next commit. The current working directory is the folder in which the file(s) one is working on are contained. It can be initialized into a repository in order for changes to start being tracked with the first commmit. I think that it adds the value that files are not automatically committed to the repository each time a commit is made. The developer has to make the decision to add the files from the current working directory to the staging are to be placed in the repository. Sometimes, it might not be the best idea for all of the files in the current working directory to be added into the repository. 
	
How can you use the staging area to make sure you have one commit per logical
change?

	Using the staging area, one can view the differences between the working directory and the staging area (using git diff) and between the staging area and the most recent commit (using git diff --staged). This makes it possible to observe the changes and make sure that only one logical change has been made. Otherwise, the files can be removed from the staging area and only the appropriate files committed to the repository. The staging area is an interesting idea that I am still trying to completely understand, but it seems to be useful in order to prevent unintended changes from being added to the repository every time a commit is completed (using git commit -m 'commit message').

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

	Branches could be used when one wants to make a different version of a project, perhaps a more difficult version, or try out an unproven feature. Branches allow for a working copy of the project to remain the master branch while these experiments are made on different branches named for their purpose. A new branch could be created to try out a change while maintaining a working copy of the main branch. All of the branches will have their own commit history and log that can be viewed to track changes in the branch. 

How do the diagrams help you visualize the branch structure?

	Non-linear structures are inherently difficult to visualize, which means that having the actual diagram is a valuable tool for understanding what is going on with a git repository. Illustrating the branches with their associated commits allows one to see the progress of an entire repository and how different parts have evolved over time. The diagram is definitely helpful to my understanding of commits, detached HEAD state, branches, git log, and how they all function together. 

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

	Merging two branches together keeps any lines that were added in a file in one of the branches, does not keep a line if it was present in the original (last shared branch) but not in one of the two files, and keeps lines that were present in the original file and present in both of the files on both branches. Git merge joins the branch specified into the branch one currently has checkout out. It is represented on the diagram showing one brach joined into another and also makes it possible to view the parent commits of each branch leading up to the merge. The commit history of each branch will now be viewable by using git log on the branch that results from the merge (not a new branch but an existing one with the other branch merged into it). All of the parent commits of both branches will be visible, so the branch that was merged can be deleted without rendering the commit log unreachable. 

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?
